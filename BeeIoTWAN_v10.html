<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>BeeIoTWAN_v10.html</title>
  <meta name="generator" content="Haroopad 0.13.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF);background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:5px -27px no-repeat #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:#FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:#EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:#75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:1px solid #1A3C6C;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin:0;max-width:none;min-height:0;outline:#112644 0;overflow-x:visible;overflow-y:visible;padding:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}.mermaid .label{color:#333}.node circle,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.edgePath .path{stroke:green;stroke-width:1.5px}.cluster rect{fill:#cdffb2;rx:40;stroke:#6eaa49;stroke-width:1px}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:'trebuchet ms',verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:lightgrey;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:lightgrey;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}text{font-family:'trebuchet ms',verdana,arial;font-size:14px}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x;border:0;height:3px;padding:0}hr.underscore{border-top-style:dashed!important}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:url(../img/ajax.gif) center center no-repeat #fff}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}input.task-list-item{margin-left:-1.62em}.markdown{font-family:"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-wrap:break-word}.markdown pre{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;overflow:auto;padding:.5em}.markdown pre code{border:0;display:block}.markdown pre>code{font-family:Consolas,Inconsolata,Courier,monospace;font-weight:700;white-space:pre;margin:0}.markdown code{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown mark{color:#000;background-color:#fcf8e3}.markdown table{padding:0;border-collapse:collapse;border-spacing:0;margin-bottom:16px}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}@import url(http://fonts.googleapis.com/css?family=Roboto+Condensed:300italic,400italic,700italic,400,300,700);.haroopad{padding:20px;color:#222;font-size:15px;font-family:"Roboto Condensed",Tauri,"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;background:#fff;line-height:1.6;-webkit-font-smoothing:antialiased}.haroopad a{color:#3269a0}.haroopad a:hover{color:#4183c4}.haroopad h2{border-bottom:1px solid #e6e6e6}.haroopad h6{color:#777}.haroopad hr{border:1px solid #e6e6e6}.haroopad blockquote>code,.haroopad h1>code,.haroopad h2>code,.haroopad h3>code,.haroopad h4>code,.haroopad h5>code,.haroopad h6>code,.haroopad li>code,.haroopad p>code,.haroopad td>code{font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;font-size:85%;background-color:rgba(0,0,0,.02);padding:.2em .5em;border:1px solid #efefef}.haroopad pre>code{font-size:1em;letter-spacing:-1px;font-weight:700}.haroopad blockquote{border-left:4px solid #e6e6e6;padding:0 15px;color:#777}.haroopad table{background-color:#fafafa}.haroopad table tr td,.haroopad table tr th{border:1px solid #e6e6e6}.haroopad table tr:nth-child(2n){background-color:#f2f2f2}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fdf6e3;color:#657b83;-webkit-text-size-adjust:none}.diff .hljs-header,.hljs-comment,.hljs-doctype,.hljs-javadoc,.hljs-pi,.lisp .hljs-string{color:#93a1a1}.css .hljs-tag,.hljs-addition,.hljs-keyword,.hljs-request,.hljs-status,.hljs-winutils,.method,.nginx .hljs-title{color:#859900}.hljs-command,.hljs-dartdoc,.hljs-hexcolor,.hljs-link_url,.hljs-number,.hljs-phpdoc,.hljs-regexp,.hljs-rules .hljs-value,.hljs-string,.hljs-tag .hljs-value,.tex .hljs-formula{color:#2aa198}.css .hljs-function,.hljs-built_in,.hljs-chunk,.hljs-decorator,.hljs-id,.hljs-identifier,.hljs-localvars,.hljs-title,.vhdl .hljs-literal{color:#268bd2}.hljs-attribute,.hljs-class .hljs-title,.hljs-constant,.hljs-link_reference,.hljs-parent,.hljs-type,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number{color:#b58900}.css .hljs-pseudo,.diff .hljs-change,.hljs-attr_selector,.hljs-cdata,.hljs-header,.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-shebang,.hljs-special,.hljs-subst,.hljs-symbol,.hljs-symbol .hljs-string{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#eee8d5}.MathJax_Hover_Frame{border-radius:.25em;-webkit-border-radius:.25em;-moz-border-radius:.25em;-khtml-border-radius:.25em;box-shadow:0 0 15px #83A;-webkit-box-shadow:0 0 15px #83A;-moz-box-shadow:0 0 15px #83A;-khtml-box-shadow:0 0 15px #83A;border:1px solid #A6D!important;display:inline-block;position:absolute}.MathJax_Hover_Arrow{position:absolute;width:15px;height:11px;cursor:pointer}#MathJax_About{position:fixed;left:50%;width:auto;text-align:center;border:3px outset;padding:1em 2em;background-color:#DDD;color:#000;cursor:default;font-family:message-box;font-size:120%;font-style:normal;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:15px;-webkit-border-radius:15px;-moz-border-radius:15px;-khtml-border-radius:15px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_Menu{position:absolute;background-color:#fff;color:#000;width:auto;padding:2px;border:1px solid #CCC;margin:0;cursor:default;font:menu;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_MenuItem{padding:2px 2em;background:0 0}.MathJax_MenuArrow{position:absolute;right:.5em;color:#666}.MathJax_MenuActive .MathJax_MenuArrow{color:#fff}.MathJax_MenuArrow.RTL{left:.5em;right:auto}.MathJax_MenuCheck{position:absolute;left:.7em}.MathJax_MenuCheck.RTL{right:.7em;left:auto}.MathJax_MenuRadioCheck{position:absolute;left:1em}.MathJax_MenuRadioCheck.RTL{right:1em;left:auto}.MathJax_MenuLabel{padding:2px 2em 4px 1.33em;font-style:italic}.MathJax_MenuRule{border-top:1px solid #CCC;margin:4px 1px 0}.MathJax_MenuDisabled{color:GrayText}.MathJax_MenuActive{background-color:Highlight;color:HighlightText}.MathJax_Menu_Close{position:absolute;width:31px;height:31px;top:-15px;left:-15px}#MathJax_Zoom{position:absolute;background-color:#F0F0F0;overflow:auto;display:block;z-index:301;padding:.5em;border:1px solid #000;margin:0;font-weight:400;font-style:normal;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;box-shadow:5px 5px 15px #AAA;-webkit-box-shadow:5px 5px 15px #AAA;-moz-box-shadow:5px 5px 15px #AAA;-khtml-box-shadow:5px 5px 15px #AAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_ZoomOverlay{position:absolute;left:0;top:0;z-index:300;display:inline-block;width:100%;height:100%;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}#MathJax_ZoomFrame{position:relative;display:inline-block;height:0;width:0}#MathJax_ZoomEventTrap{position:absolute;left:0;top:0;z-index:302;display:inline-block;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}.MathJax_Preview{color:#888}#MathJax_Message{position:fixed;left:1px;bottom:2px;background-color:#E6E6E6;border:1px solid #959595;margin:0;padding:2px 8px;z-index:102;color:#000;font-size:80%;width:auto;white-space:nowrap}#MathJax_MSIE_Frame{position:absolute;top:0;left:0;width:0;z-index:101;border:0;margin:0;padding:0}.MathJax_Error{color:#C00;font-style:italic}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown haroopad">
<p>Logging# BeeIoT-WAN Gateway v1.2</p><h3 id="der-gateway-zur-[beeiot-bienenstockwaage](https://github.com/mchresse/beeiot/blob/master/beeiot_v20.md)"><a name="der-gateway-zur-[beeiot-bienenstockwaage](https://github.com/mchresse/beeiot/blob/master/beeiot_v20.md)" href="#der-gateway-zur-[beeiot-bienenstockwaage](https://github.com/mchresse/beeiot/blob/master/beeiot_v20.md)"></a>Der Gateway zur <a href="https://github.com/mchresse/BeeIoT/blob/master/BeeIoT_v20.md">BeeIoT Bienenstockwaage</a></h3><h5 id="(based-on-raspberry-pi)"><a name="(based-on-raspberry-pi)" href="#(based-on-raspberry-pi)"></a>(based on Raspberry Pi)</h5><p><img src="images_v2/BIoTGW_LoraHat.jpg" width="250"></p><p><strong>04.05.2020 by Randolph Esser</strong></p><hr class="section"><h4 id="inhaltsverzeichnis:"><a name="inhaltsverzeichnis:" href="#inhaltsverzeichnis:"></a>Inhaltsverzeichnis:</h4><ul>
<li><a href="#einführung"><strong>Einführung</strong></a></li><li><a href="#rpi-gateway-aufbau"><strong>RPi-Gateway Aufbau</strong></a><ul>
<li><a href="#rpi-gateway-radiolayer">RPi-Gateway RadioLayer</a></li></ul>
</li><li><a href="#beeiot-client-aufbau"><strong>BeeIoT-Client Aufbau</strong></a><ul>
<li><a href="#client-function-flow">Client Function Flow</a></li><li><a href="#client-data-security">Client Data Security</a></li></ul>
</li><li><a href="#beeiot-lora-wan"><strong>BeeIoT LoRa WAN</strong></a><ul>
<li><a href="#beeiotwan-channel-switch">BeeIoTWAN Channel Switch</a></li><li><a href="#beeiotwan-communication-packets">BeeIoTWAN Communication packets</a><ul>
<li><a href="#beeiotwan-base-packet">BeeIoTWAN Base Packet</a></li></ul>
</li><li><a href="#beeiotwan-join">BeeIoTWAN JOIN</a></li><li><a href="#client-tx/rx-sessions">Client TX/RX Sessions</a></li><li><a href="#der-gateway/server-empfangsstack">Der Gateway/Server Empfangsstack</a><ul>
<li><a href="#radio-service---class-radio">Radio Service - class Radio</a></li><li><a href="#network-service---class-nwsrv">Network Service - class NwSrv</a></li><li><a href="#join-service---class-joinsrv">JOIN Service - class JoinSrv</a></li><li><a href="#application-services---class-appsrv">Application Services - class AppSrv</a></li></ul>
</li></ul>
</li><li><a href="#biot-Command-Interface"><strong>BIOT Command Interface</strong></a></li><li><a href="#logging"><strong>Logging</strong></a></li><li><a href="#beeiot-todo-liste"><strong>BeeIoT ToDo Liste</strong></a><!-- toc -->
</li></ul><hr class="section"><h2 id="einführung"><a name="einführung" href="#einführung"></a>Einführung</h2><p>Nach der Beschreibung der <a href="https://github.com/mchresse/BeeIoT/blob/master/BeeIoT_v20.md">BeeIot Sensor Knoten</a> auf Basis des ESP32 chipset (siehe <a href="https://Github.com/mchresse/BeeIoT">https://Github.com/mchresse/BeeIoT</a>), nun die passende Gegenstelle auf Raspberry Pi Basis.</p><p>Diese erfüllt (ähnlich wie bei LoRa-Wan) folgende Rollen/Services:</p><ul>
<li>Gateway Server (inkl. RADIO Service)<ul>
<li>Konfiguration der Transmit channels abhängig von der Knoten session</li><li>Entgegennahme der BIoT LoRa Pakete (Uplink) auf der vereinbarten Modem Channel configuration</li><li>Versenden von BIoT Antwort Paketen.</li></ul>
</li><li>NetworkServer<ul>
<li>Koordination der RX/TX Paket</li><li>Evaluation des Paket headers und Weiterleitung an den Application server</li><li>Bedienung des RX1 Commando Fensters im Anschluss an jedes Node Paket (optional)</li></ul>
</li><li>JOIN Server<ul>
<li>Evaluierung von JOIN requests auf Basis einer statischen DevUID Referenztabelle</li><li>Verwaltung einer dynamischen Node Tabelle incl RX/Queue.</li><li>Verwaltung der Verschlüsselung und zug. keys</li></ul>
</li><li>Application Server<ul>
<li>Auswertung des Frame-Payloads Applikations-spezifisch nach zugewiesener AppEUI.</li><li>Default App: BIoT zur Auswertung der BeeIoT Node Sensordaten</li><li>Weiterleitung der validierten Datenpakete für eine Webdarstellung in Form einer CSV Datei</li></ul>
</li></ul><h3 id="rpi-gateway-aufbau"><a name="rpi-gateway-aufbau" href="#rpi-gateway-aufbau"></a>RPi-Gateway Aufbau</h3><p>Bevor wir tief in die LoRa SW Stack details eintauchen, zunächst der HW AUfbau des RaspberryPi Gateway.<br>Im Single Channel Betrieb müsste leistungsmäßig ein RPi-ZeroW reichen (Der Prototyp wurde mit einem RPi 3+ gestartet).<br>Im folgende Diagramm sieht man das Gesamtkonzept von Sensor-Client über Gateway zum WebServer User Interface (HMI):<br><img src="images_v2/BeeIoT_Concept.jpg"><br>Alle Clients kommunizieren per default via Lora-Funk mit dem Gateway, dessen Pakete über einen JOIN Server (dazu später mehr) an die dahinter liegenden Applikation-Services zur Erst-Verarbeitung weitergereicht werden. Diese Evaluieren die LoRa Paket Frame-Payloads und extrahieren die Sensordaten zur Ablage in einer zentralen Client Datenbank. Via REST oder MQTT oder auch FTP werden die Daten an Darstellungs-Services wie der eigenen Webseite weitergeleitet.</p><p>Da in der Regel nur alle 10-15 Minuten Datenpakete der Clients (mit einer Laufzeit von 150-200ms) übertragen werden, bleibt genügend Rechenzeit die Pakete zu dekodieren, und in passende Übertragungsformate zu wandeln.<br>Die LAN/WiFi Anbindung ist dank Raspberry HW+OS bereits abgedeckt (Details siehe ggfs. auch in der Doku zum <strong><a href="https://github.com/mchresse/BeeLog/blob/master/BeeLogDoc_v1.3.md">“BeeLog-Projekt: BeeLogDoc_v1.3.md”</a></strong> auf GitHub). Daher ist “nur noch” ein LoRa Modul nötig.<br>Der Semtech Chip SX1276 ist der kostengünstige Standard für Lora Übertragung und in vielen HAT-Varianten verbaut. Ich habe hier den Dragino_Lora_Hat v1.4 für 868MHz mit optionalem GPS Empfänger verwendet:<br><img src="images_v2/Dragino_Lora_Hat.jpg"><br>Eine einfache passive Antenne ist per SMA Stecker schnell angebracht.<br>Einfach auf den RPi aufstecken, die RPi-SD Karte mit Debian OS installieren und los gehts:</p><p>Für die Ansteuerung des Dragino Hat’s muss über das raspi-config tool noch der SPI Channel aktiviert werden und die universelle wiringPi Library downloaded und installiert werden (siehe auch dazu in der o.a. Doku des BeeLog Projektes).</p><p>Die vom HAT verwendeten SPI- und weitere Steuerleitungen sind in der Header-Datei <em>beelora.h</em> festgehalten:</p><pre class="cpp hljs"><code class="cpp" data-origin="<pre><code class=&quot;cpp&quot;>// Dragino RPi Hat with SX127x at Raspberry 40p connection: -&amp;gt; wPi Mode !
#define CFG_sx1276_radio        // type of Dragino Hat LoRa chip
//                WirePi-Pin:
#define LORAcs      6   // GPIO 25          Pin 22
#define LORAdio0        7   // GPIO 4                Pin 7
#define LORAdio1        4   // GPIO 23            Pin 16
#define LORAdio2        5   // GPIO 24            Pin 18
#define LORArst     0   // GPIO 0                Pin 11
#define LORAmosi        12  // GPIO 10 MOSI Pin 19
#define LORAmiso    13  // GPIO 9  MISO Pin 21
#define LORAsck     14  // GPIO 11 SCLK Pin 23
#define RXled       LORAdio0
#define GPStxd      15  // GPIO 15 TxD -&amp;gt; GPS
#define GPSrxd      16  // GPIO 16 RxD -&amp;gt; GPS
</code></pre>"><span class="hljs-comment">// Dragino RPi Hat with SX127x at Raspberry 40p connection: -&gt; wPi Mode !</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> CFG_sx1276_radio        <span class="hljs-comment">// type of Dragino Hat LoRa chip</span></span>
<span class="hljs-comment">//                WirePi-Pin:</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LORAcs      6   <span class="hljs-comment">// GPIO 25          Pin 22</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LORAdio0        7   <span class="hljs-comment">// GPIO 4                Pin 7</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LORAdio1        4   <span class="hljs-comment">// GPIO 23            Pin 16</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LORAdio2        5   <span class="hljs-comment">// GPIO 24            Pin 18</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LORArst     0   <span class="hljs-comment">// GPIO 0                Pin 11</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LORAmosi        12  <span class="hljs-comment">// GPIO 10 MOSI Pin 19</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LORAmiso    13  <span class="hljs-comment">// GPIO 9  MISO Pin 21</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LORAsck     14  <span class="hljs-comment">// GPIO 11 SCLK Pin 23</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> RXled       LORAdio0</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> GPStxd      15  <span class="hljs-comment">// GPIO 15 TxD -&gt; GPS</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> GPSrxd      16  <span class="hljs-comment">// GPIO 16 RxD -&gt; GPS</span></span>
</code></pre><p><strong>Geplante Erweiterung:</strong><br>Will man die aktuelle Single Channel HAT Variante um weitere Lora-Channel erweitern,<br>bestellt man sich einfach weitere Semtech Module a la RFM95 (wie auf dem HAT und bei allen Clients verbaut) und lötet sie parallel Piggy Back oben auf.<br><img src="images_v2/SX1276.jpg"><br>Als Auflötpunkte können die Vcc und Gnd Leitungen sowie die shared SPI Leitungen (SCK, MISO, MOSI) verwendet werden. Alle anderen DIO3-5 bleiben ungenutzt.<br>Folgende Anschlüsse müssen exra an einen RPi GPIO Port frei verdrahtet werden:<br>LoRacs(NSS), LORAdio0-2, LORArst.<br>So kann man den 2. SX1276 separat über eine eigene SPI Adresse ansprechen, indem man in der SW eine neue Lora-Instanz mit den o.g. NSS und RST GPIO-Ports erzeugt.</p><p>Der aktuelle Aufbau besteht aber noch aus der SingleChannel Version.<br>Das dadurch entstandene “RPi/HAT Paket” wird noch in eine IP67 Dichte Box verpackt (die Antenne kann bei einer Plastikbox auch intern bleiben), die LAN Leitung  wasserdicht umhüllt von einem Wetterschutzrohr herausgeführt, an den Antennenmast geschraubt. Die LAN Leitung habe ich innerhalb des Rohrs ins Haus geleitet.<br>Das ist der optimale Punkt um im Radius von 3-4km alle Bienenstandorte zu erreichen.</p><p>Ggfs. kann die Reichweite noch durch eine rundstrahlende LoRa Aktiv-Antenne (ca. 120€) mit +6dBm verbessert werden, macht aber für die BeeIoT-SW keine Unterschied.</p><h4 id="rpi-gateway-radiolayer"><a name="rpi-gateway-radiolayer" href="#rpi-gateway-radiolayer"></a>RPi-Gateway RadioLayer</h4><p>Die SX1276 Konfiguration, die Steuerung der Paketübertragung sowie das IRQ handling via eigener IRQ callback Funktion habe ich abgeleitet vom LMIC radio Layer native nachimplementiert, dabei aber weitgehend die API des LMIC radio layers beibehalten.<br>Der NwServer verwendet folgende Schnittstellen Funktionen:</p><pre class="cpp hljs"><code class="cpp" data-origin="<pre><code class=&quot;cpp&quot;>- SetupLora()            // Detect and Initialize SX1276 chip
    * configChannel()    // preset configchannel seetings by ChannelIndex
    * configLoraModem()  // preset LoRa Modem settings for BIoT channels
    * radio_init()       // preset random matrix
    * myisr_init();      // Assign ISRs to IRQ Port DIO0-2
- starttx()              // final Packet TX routine
- startrx()              // enable RX Mode (single + contig.) -&amp;gt; in combination with ISR()
</code></pre>">- SetupLora()            <span class="hljs-comment">// Detect and Initialize SX1276 chip</span>
    * configChannel()    <span class="hljs-comment">// preset configchannel seetings by ChannelIndex</span>
    * configLoraModem()  <span class="hljs-comment">// preset LoRa Modem settings for BIoT channels</span>
    * radio_init()       <span class="hljs-comment">// preset random matrix</span>
    * myisr_init();      <span class="hljs-comment">// Assign ISRs to IRQ Port DIO0-2</span>
- starttx()              <span class="hljs-comment">// final Packet TX routine</span>
- startrx()              <span class="hljs-comment">// enable RX Mode (single + contig.) -&gt; in combination with ISR()</span>
</code></pre><p>Die vom Radio-Layer implizite bei jedem IRQ aufgerufene ISR-Callback Funktion:</p><pre><code data-origin="<pre><code>- myradio_irq_handler()  // ISR-callback for RXDone and TXDone IRQs
</code></pre>">- myradio_irq_handler()  // ISR-callback for RXDone and TXDone IRQs
</code></pre><p>setzt im TX Mode zur Best#tigung der Sendung das <em>BeeIotTXFlag</em> und füllt im RX-Mode die RXQueue mit den Empfangs-Paketdaten und setzt schliesslich das <em>BeeIotRXFlag</em>-Semaphor.</p><h3 id="beeiot-client-aufbau"><a name="beeiot-client-aufbau" href="#beeiot-client-aufbau"></a>BeeIoT-Client Aufbau</h3><p>Der Grundsätzliche HW Aufbau des <a href="https://github.com/mchresse/BeeIoT/blob/master/BeeIoT_v20.md">“BeeIot Sensor Knoten”</a> wurde ja schon im BeeIoT Projekt beschrieben.<br>Zum Verständnis für die SW Stack Beschreibung zusammenfassend:</p><ul>
<li>Der Client verwendet ebenfalls die SX1276 Module diskret angeschlossen via SPI GPIO Ports z.B. eines ESP32</li><li>Als Radio layer wird die Library von <strong>“SanDeepMistry”</strong> verwendet: <a href="https://github.com/sandeepmistry/arduino-LoRa">https://github.com/sandeepmistry/arduino-LoRa</a> aktuell in der version<ul>
<li>Diese unterstützt: HopeRF RFM95W, RFM96W, and RFM98W Module sowie das dragino Bee Lora shield. (allesamt Semtech Module)</li></ul>
</li></ul><p>Die Inbetriebnahme des LoRa Moduls wird dadurch sehr einfach.<br>Hier zunächst die wichtigsten Funktionen:</p><ul>
<li>Wird einanderer SPI Port als der default (SPI0) verwendet (optional):<pre class="cpp hljs"><code class="cpp" data-origin="<pre><code class=&quot;cpp&quot;>LoRa.setSPI(myspi);                  // new SPI Instanz of spi_t
LoRa.setSPIFrequency(spi-frequency); // default: 8MHz
</code></pre>">LoRa.setSPI(myspi);                  <span class="hljs-comment">// new SPI Instanz of spi_t</span>
LoRa.setSPIFrequency(spi-frequency); <span class="hljs-comment">// default: 8MHz</span>
</code></pre>
</li><li>Instanziierung des LoRa Ports<pre class="cpp hljs"><code class="cpp" data-origin="<pre><code class=&quot;cpp&quot;>LoRa.begin(LoRaCfg.freq);           // default: EU868.1
</code></pre>">LoRa.begin(LoRaCfg.freq);           <span class="hljs-comment">// default: EU868.1</span>
</code></pre>
</li><li>Zuweisung der GPIO Leitungen dem SPI Protokoll Port (siehe beeiot.h)<pre class="cpp hljs"><code class="cpp" data-origin="<pre><code class=&quot;cpp&quot;>LoRa.setPins(BEE_CS, BEE_RST, BEE_DIO0);// set CS, reset, IRQ pin
</code></pre>">LoRa.setPins(BEE_CS, BEE_RST, BEE_DIO0);<span class="hljs-comment">// set CS, reset, IRQ pin</span>
</code></pre>
</li><li>Das Senden eines Paketes startet mit der Reservierung eines TX Buffers:<pre class="cpp hljs"><code class="cpp" data-origin="<pre><code class=&quot;cpp&quot;>LoRa.beginPacket(implHdr);   // for BIoT: implHdr=0 -&amp;gt; explicite Header only
LoRa.write(byte);            // write single Byte to TX Buffer
LoRa.write(&amp;amp;date, len);      // write byte stream with &quot;len&quot; Byte to TX buffer
LoRa.endPacket(async);       // send buffer; async=0 - &amp;gt; wait for TXDone IRQ
</code></pre>">LoRa.beginPacket(implHdr);   <span class="hljs-comment">// for BIoT: implHdr=0 -&gt; explicite Header only</span>
LoRa.write(byte);            <span class="hljs-comment">// write single Byte to TX Buffer</span>
LoRa.write(&amp;date, len);      <span class="hljs-comment">// write byte stream with "len" Byte to TX buffer</span>
LoRa.endPacket(async);       <span class="hljs-comment">// send buffer; async=0 - &gt; wait for TXDone IRQ</span>
</code></pre>
Man kann auch eine TXDone Service Routine anmelden, ist BIoT client aber nicht nötig, da keine Parallelität verlangt wird, und der sync mode hinreichend prüft.<blockquote>
<p>Problem: Bleibt der TXDone aus -&gt; Exception: muss in SW angefangen werden.</p>
</blockquote>
</li><li>Vorbereitung zum Empfang von Paketen: Zuweisung einer IRQ CallBack Routine:<pre class="cpp hljs"><code class="cpp" data-origin="<pre><code class=&quot;cpp&quot;>LoRa.onReceive(onReceive);   // Type: void onReceive(int pkglen);
</code></pre>">LoRa.onReceive(onReceive);   <span class="hljs-comment">// Type: void onReceive(int pkglen);</span>
</code></pre>
Die ISR: onReceive(len) Funktion wird aufgerufen, wenn ein Paket vollständig in der FiFo des SX1276 eingetroffen ist (inkl. CRC check).</li><li>Aktivierung des RX-Contiguous Mode (dauerhaftes Warten auf Pakete)<pre class="cpp hljs"><code class="cpp" data-origin="<pre><code class=&quot;cpp&quot;>LoRa.receive();   // No Parameter -&amp;gt; explicite header Mode
</code></pre>">LoRa.receive();   <span class="hljs-comment">// No Parameter -&gt; explicite header Mode</span>
</code></pre>
</li></ul><h3 id="client-function-flow"><a name="client-function-flow" href="#client-function-flow"></a>Client Function FLow</h3><p>Ein standard Arduino Sketch besteht aus der Setup() und der Loop() Phase:<br>Bei PowerOn startet der Boot Loader erst einmalig die Setup Phase. Anschliessend wird die Loop Funktion in einer Endlosschleife aufgerufen. Es sei denn, man geht am Ende in den Sleep() Mode. Beim darauffolgenden WakeUp (z.B. RTC getriggert) startet der bootLoader wiederum die Setup Phase.<br>Aus diesem Grund wird in der Setup-Funktion als erstes ein “reentrant Check” über ein resident gespeichertes Exit-Mode Flag durchgeführt.<br>Wird ein Sleep/Wakup Cycle erkannt, werden die residential gespeicherten Runtime Daten, welche beim Sleep Einstieg gespeichert wurden, zur Initialisierung der Betriebsstrukturen zurückgeladen. Ggfs. werden alle Sub-Setup Routinen der Sensorkomponenten nochmal durchlaufen, diesml aber im Reentrant Mode, falls eine Fallunterscheidung nötig ist.</p><p>Nach der Setupphase, in der alle Sensor- und Kommunikationsmodule sowie das ePaper Display discovered wurden, und ggfs. die letzten Runtime parameter rückgeladen wurde, folgt die eigentlich Sensor monitoring Loop:</p><ol>
<li>Erfassung der “überlebenswichtigen” Runtime parameter</li><li>Sammeln aller Sensordaten</li><li>Evaluierung von Treshold bedingten Events für Sofortmassnahmen</li><li>Report der Datensätze lokal (ePaper + SDCard) wie remote (LoRa, Wifi, BT)</li><li>Einleitung der Sleep Phase</li></ol><p>Der BIoTWAN Radio Layer versteckt sich im Gesamt-FunctionFlow des Clients in der Sensor-Report Funktion über remote-Kanäle:</p><p><img src="images_v2/Node_Fkt_Flow.jpg"></p><h3 id="client-data-security"><a name="client-data-security" href="#client-data-security"></a>Client Data Security</h3><p>Für das Lora Protokoll ist der Erhalt des Runtime Parameter Status essentiell wichtg um ev. Paketübertragungszähler oder Encoding Keys weiter zu verwenden.</p><p>Dies ist nötig um ein Minimum der BIoT Protokoll Sicherheitsfunktionen aufrecht zu erhalten:<br>Denn der GW würde weitere Anfragen zurückweisen, wenn nicht der richtige Paketzähler im Payload (welcher mit dem richtigen Schlüssel enkodiert wurde) der Sendung enthalten ist. Das verhindert eine Man-In-the-Middle Attack des BIoT Protokolls und damit der gesamten LoRa Kommunikation.<br>Würde man bei jedem WakeUp einen JOIN Request mit rückgesetzten Zählern starten, könnte das jeder tun, der sich der DevEUI+JoinEUI-Keys bemächtigt hat (dazu später mehr).<br>So muss der JOIN Prozess einmalig in “geschütztem” Umfeld erfolgen, aber alle weiteren Konnektierungsversuche können mit einem REJOIN Kommando erfolgen, welches akt. Zaehler und Keys voraussetzt.</p><p>Da der Private key zur Entschlüsselung ausschliesslich auf GW Seite im JOIN Service vorgehalten wird sind auch die Clientseitig gespeicherten SDCard Daten soweit sicher vor einem Intruder-Attack.<br>Das LoRaWAN[^TM] Protokoll legt speziell in dre Version v1.1 weitere Vorgaben (Stichwort: Rekeyeing) zur Absicherung u.a. auch folgender REJOIN Requests fest, würde aber bei der Bedeutung der BeeIoT Daten den Aufwand zur Verwaltung sprengen. Am Ende geht es um Bienenstockdaten, nicht um Fertigungsstrecken.</p><p>In einer professionellen Anwendung würde man auf beiden Seiten die sicherungswürdigen Schlüssel z.B. in einem Security chip a la TPM/Xsensiv ablegen.</p><p>Die auf der Client Seite getroffen Massnahmen zur Zählerverwaltung und Verschlüsselung müssen natürlich auf Gateway- sowie NwServer Seite entsprechend auch unterstützt werden.</p><h2 id="beeiot-lora-wan"><a name="beeiot-lora-wan" href="#beeiot-lora-wan"></a>BeeIoT LoRa WAN</h2><p>Nun aber zum Prinzip des eigentlichen BeeIoT-WAN Protokolls:</p><p>Für die remote Connection zu den BeeIoT Clients/Knoten ohne “stromfressenden” WiFi Betrieb oder nicht-erreichbarem Hotspot, ist ein LoRa Funktmodul vorgesehen.<br>Auf 868.1MHz voreingestellt kann es abhängig von der räumlichen Topologie Reichweiten bis zu 8km ermöglichen.</p><p>Die LoRa modulierte Funkübertragung ermöglicht geringe Band-Belastung und geringem Stromverbrauch durch möglichst kurze on-air Phasen bei max. Reichweite. Und das in einem freien Band von 868MHz.<br>Das dafür entwickelte LoRaWAn(TM) Protokoll ist sehr ausgereift, erscheint aber für private Netzwerke in kleinem Umfang von der Komplexität her überdimensioniert.<br>Zwar werden auch Private Netzwerke unterstützt, eine Zertifizierung bei der Alliance wäre aber dennoch sinnvoll nötig, wenn man in einem LoRaWAn Netzwerk auch kompatible Gateways und NetzwerkServer unterhalten will.</p><p>Da ein GW ggfs. mit mehreren Clients quasi-gleichzeitig zu tun hat, die ihrerseits aber unterschiedliche Abnehmer (Apps) in Verbindung stehen, habe ich eine OSI Stack ähnliche Struktur definiert, um das Paketmanagement, die Kontrolle des Übertragungsmediums, und das Switching zu Applikations-Diensten zu koordinieren:<br><img src="images_v2/BeeIoT_OSIStack.jpg"></p><p>Die Netzwerkverwaltung oberhalb des Radiolayers z.B. in Form des <strong><a href="https://lora-alliance.org/about-lorawan">LoRaWAN(TM) Protokolls</a></strong> leisten z.B. folgende Bibliotheken (z.B. die OSS Lib: LMIC von IBM -&gt; search in GitHub) oder Radiohead.<br>Ein weiterer interessanter Client sample Code findet sich über eine Beispielprojekt des Opennet teams: <a href="https://wiki.opennet-initiative.de/wiki/LoRaSensor">https://wiki.opennet-initiative.de/wiki/LoRaSensor</a> .</p><p>Bei LMIC nimmt der sogenannte “OS” Layer einem das Queueing hereinkommender Pakete sowie die protokollgerechte Quittierung sowie das Bandmanagement vollständig ab.<br>Darin sind eine Peer2Peer Verbindung über unique Sender/Empfänger IDs und AES128-Verschlüsselungs ähnlich wie bei TCP/IP kombiniert mit SSH enthalten.<br>Es zeigten sich aber bei der Migration der LMIC Lib v1.6 Instablitäten des LoRa Modes<br> -&gt; es wurden immer wieder FSK Mode IRQs empfangen, was die LoRa Statusführung stoppte.<br>Auch ist das von IBM gewählte OS layer Model nicht so handsam wie erwartet.<br>In Summe stellte die LMIC-Lib für den ESP32 in Kombination mit den übrigen Aktionen zur Sensorbehandlung zumindest auf Node/Cient Seite einen ziemlichen overhead dar, der aber leider nötig ist um das vollständige LoRa-WAN Protokoll nach Spezifikation zu erfüllen (e.g. Band-Hopping, LoRaWAN v1.1 Encryption key handling, channel calibration usw.).</p><p>Angelehnt an den RADIO Layer (radio.c) von LMIC v1.6 ist für dieses Projekt ein eigenes Single-Channel WAN Protokoll entstanden (BeeIoT-WAN) welches die Paket Kommunikation auf den grundsätzlichen Austausch von Sensordaten mit einfacher Quittierung (zunächst ohne Multi-Bandmanagement) “optimiert”.</p><p>Aus diesem Grund habe ich eine abgestrippte Variante entworfen, die den BeeIoT Anforderungen gerecht wird und sich leichter in den äußeren Ablaufrahmen (speziell beim ESP32: DeepSleep) migrieren lässt:</p><ol>
<li>Lora Modem Mode only (kein FSK) -&gt; einfacherer Code bei ISR, RX/TX Routinen</li><li>Einfache OTAA Aktivierung -&gt; Erleichtert die Fernwartung mehrer Knoten im Störfall</li><li>Dynamische Configuration channel Vorgabe server side -&gt; zur Störfall Anpassung</li><li>Paketgrößen bis zu 250Byte (exkl. header) mind. 10x / Stunde möglich</li><li>Erkennung durch Sender/Empfänger-IDs im “BeeIoT-WAN”-eigenen Header</li><li>CRC basierte Datenprüfung</li><li>automatische Quittierung und resend/retry Kommunikation als Flow Control</li><li>Knoten =&gt; Single Channel, Gateway =&gt; Multichannel (optional)</li><li>FW Update (optional)</li><li>SD Karten Lesen/Schreiben (optional)</li><li>Reichweite 3-4 km -&gt; Radius der Standorte</li><li>Master jeder Session ist der Knoten; der Server darf aber eine Anfordeurng am Ende jeder Session (RX1-Fenster) anmelden.</li><li>Bei Connection-Loss erfolgen knotenseitig REJOIN Versuche mit ansteigender Wartezeit (zur Stromeinsparung) -&gt; Sensordaten werden weiter lokal gespeichert (e.g. SDCard)</li></ol><p>Die Störfälle sind bekanntermaßen:</p><ul>
<li>Atmosphärische Strahlung (Sonne)</li><li>Reflexionen von Gebäuden (Echo Effekte)</li><li>Sender auf gleichem Configuration channel (Frequenz, Bandbreite, Spreading factor,…)</li><li>temporäre Ausfälle von Knoten und Gateway</li></ul><p>Natürlich wurden diese Designvorgaben für beide SW Stacks auf Client und Server-Seite angewandt.</p><p>Zur Übersicht der beidseitigen Kommunikations Layer inAnlehnung an das OSI Mdell und als referenz für die folgenden Artikel, hier der vollständige Function-Flow Plan wie er aktuell in BIoTWAN v1.0 implementiert wurde:</p><p><img src="images_v2/BeeIoT_ProtocolOvw.jpg"></p><p>Auf der linken Client-Seite sind die Setup() und die Loop Funktion zu erkennen.<br>Von ihnen ausgehend erfolgen alle Aktionen, da zu allen Phasen der Kommunikation der Client der Master ist (mal vom RX1 Fenster abgesehen).</p><p>Am Ende der LoRa Setup Phase erfolgt bereits der erste JOIN Versuch mit dem BIoT Netzwerk. Ist dieser erfolgreich wechselt der Runtime Status in BIoT_IDLE was bedeutet: RX/TX ready.<br>Schlägt der JOIN Request fehl, gibt es eine Anzahl Retries mit abnehmender Wiederholfrequenz als Teil der eigentlichen Loop Sequenz.<br>Dazu wird am Anfang eines jeden Reportversuchs über LoRaLog() der Modem Status geprüft:</p><ul>
<li>BIOT_NONE -&gt; Erneute SPI-Suche nach einem LoRa Modem via Setup_Lora()</li><li>BIoT_JOIN -&gt; weitere JOIN Versuche nötig; solange ist kein TX Mode möglich</li><li>BIoT_SLEEP-&gt; WakeUp des LoRa Modems nötig + Modem configuration</li><li>BIoT_IDLE -&gt; Alles O.k.: die Sensor-Report Daten können im TX Mode gesendet und im RX Mode ein ACK/RX1-Paket empfangen werden.<ul>
<li>Im Fehlerfall erfolgen auch hier Retries clientseitig bzw. der Server kann im RX1 Fenster einen Retry- oder REJOIN Antrag stellen (z.B. wenn der Paketheader in Ordnung war (d.h. konnte einer App zugeordnet werden), die Frame-Payloaddaten waren aber korrupt.</li></ul>
</li><li>BIOT_RX/TX -&gt; gibt der ISR Funktion zur Validierung den erwarteten IRQ Typs des eingetroffenen IRQ Requests via DIOx Leitung an.</li></ul><h3 id="beeiotwan-channel-switch"><a name="beeiotwan-channel-switch" href="#beeiotwan-channel-switch"></a>BeeIoTWAN Channel Switch</h3><p>Um gehäuften Konflikten auf einem ConfigChannel ausweichen zu können, werden sowohl im Gateway als auch in jedem Knoten folgende ConfigChannel Datensätze geführt, zwischen denen der Netzwerk Service bei einer OTAA Join Session auswählen kann:</p><table>
<thead>
<tr>
<th>Index</th>
<th>Frequence</th>
<th>Band</th>
<th>Spreading Start</th>
<th>Spreading End</th>
<th>CodingRate</th>
<th>TxPower</th>
<th>DutyTime</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>EU868.1</td>
<td>125kHz</td>
<td>SF7</td>
<td>SF12</td>
<td>CR4_5</td>
<td>14</td>
<td>10x</td>
</tr>
<tr>
<td>1</td>
<td>EU868.3</td>
<td>125kHz</td>
<td>SF7</td>
<td>SF12</td>
<td>CR4_5</td>
<td>14</td>
<td>10x</td>
</tr>
<tr>
<td>2</td>
<td>EU868.3</td>
<td>250kHz</td>
<td>SF7</td>
<td>SF7</td>
<td>CR4_5</td>
<td>14</td>
<td>10x</td>
</tr>
<tr>
<td>3</td>
<td>EU868.5</td>
<td>125kHz</td>
<td>SF7</td>
<td>SF12</td>
<td>CR4_5</td>
<td>14</td>
<td>10x</td>
</tr>
<tr>
<td>4</td>
<td>EU867.1</td>
<td>125kHz</td>
<td>SF7</td>
<td>SF12</td>
<td>CR4_5</td>
<td>14</td>
<td>1x</td>
</tr>
<tr>
<td>5</td>
<td>EU867.3</td>
<td>125kHz</td>
<td>SF7</td>
<td>SF12</td>
<td>CR4_5</td>
<td>14</td>
<td>1x</td>
</tr>
<tr>
<td>6</td>
<td>EU867.5</td>
<td>125kHz</td>
<td>SF7</td>
<td>SF12</td>
<td>CR4_5</td>
<td>14</td>
<td>1x</td>
</tr>
<tr>
<td>7</td>
<td>EU867.7</td>
<td>125kHz</td>
<td>SF7</td>
<td>SF12</td>
<td>CR4_5</td>
<td>14</td>
<td>1x</td>
</tr>
<tr>
<td>8</td>
<td>EU867.9</td>
<td>125kHz</td>
<td>SF7</td>
<td>SF12</td>
<td>CR4_5</td>
<td>14</td>
<td>1x</td>
</tr>
<tr>
<td>9-14</td>
<td>reserved</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>EU869.525</td>
<td>125kHz</td>
<td>SF7</td>
<td>SF12</td>
<td>CR4_5</td>
<td>14</td>
<td>1x</td>
</tr>
</tbody>
</table><p>CC0 ist der default Config Channel und CC15 wird für datenintensive Downlink Aktionen verwendet.<br>Dank dieser verteilten Tabelle muss nur der ConfigChannel-Index bei einem CONFIG Kommando zw. Client und Server übertragen werden und beide Seiten stellen sich auf den neuen Kanal bei der nächsten Session ein. Läuft etwas schief -&gt; Rückfall auf den default Channel mit einem Rejoin Versuch durch den Client (Zaehler und Keys bleiben dann aber unverändert).</p><h3 id="beeiotwan-communication-packets"><a name="beeiotwan-communication-packets" href="#beeiotwan-communication-packets"></a>BeeIoTWAN Communication Packets</h3><p>Zum Austausch zwischen 2 Instanzen bedarf es einer gemeinsamen Sprache und gemeinsamen Syntax.<br>Diese gemeinsamen Festlegungen (typedefs) wurden in der Header Datei BIoTWAN.h zusammengefasst.</p><p>Die ausgetauschten Pakete zwischen Knoten und Gateway/NwServer haben folgendes Format:<br><img src="images_v2/BeeIoT_PkgFormat.jpg"></p><p>Der SX1276 chip befasst sich mit der reinen Rohdatenübertragug und Kanalsynchronisierung (oranger Bereich).<br>Der Radio Layer transportiert davon den grünen Bereich, die Intepretiert des darin enthaltenen Headers wird vom NwServer übernommen. Durch die MIC validierung stellt er auch die Konsistenz des Daten-Paketes sicher.<br>Der verschlüsselte gelbe Bereich ist dem AppServer vorbehalten, der anhand seiner private Keys die Entschlüsselung des frame-payload durchführt.<br>Erst dann stehen die eigentlichen Sensordaten zur Weiterverarbeitung zur Verfügung.</p><h4 id="beeiotwan-base-packet"><a name="beeiotwan-base-packet" href="#beeiotwan-base-packet"></a>BeeIoTWAN Base Packet</h4><p>Das Basis-Datenpaket hat folgendes Format (beeiotpkg_t):</p><ul>
<li>Header (beeiot_header_t)<ul>
<li>Destination ID -&gt; Das ist die ID des Paket-Empfängers</li><li>Sender ID -&gt; ID des Absenders</li><li>Pkg-index -&gt; Fortlaufender Paket Index (0..255) zur Validierung der Paketsequenz durch den NwServer</li><li>NwsCMD -&gt; Das Protokoll Kommanando -&gt; U.a. Zur Differenzierung ob NwServer Paket oder AppService Paket</li><li>Length Payload -&gt; Die Länge des folgenden Payload Streams in Byte incl. MIC(4):<br>(BIoT_DLEN = 0 … MAX_PAYLOAD_LENGTH8128) - BIoT_HDRLEN(5))</li></ul>
</li><li>Payload (data)<ul>
<li>Falls NwServer CMD: weitere Parameter zum NwServer Kommaando</li><li>Falls AppServer CMD: encoded Payload Data für den AppServer</li></ul>
</li><li>MIC: 4Byte AES128 Schlüssel über das esamte Paket (excl. MIC)</li></ul><p>Der Client erhält die Destination- und Sender-ID beim JOIN Protokoll vom NwServer mitgeteilt.<br>Für das JOIN Protokoll selbst werden Defaultwerte verwendet (CfgChn0, GWIDx, NODEIDBASE).<br>Die Start Packet ID wird erst bei einem Client JOIN-Request seitens NwServer via CONFIG-Ack mitgeteilt. Als Master des Protokolls verwaltet der Client das nachfolgende Hochzählen dieser ID. Es gibt nur eine Packet-ID unabhängig der Sendungsrichtung, und der akt. Wert ist der Einfachheit-halber über die akt. Session hinweg gültig.<br>(ToDo: getrennte Zaehler für beide Richtungen würde die Sicherheit erhöhen).</p><p>Die Bedeutung des eigentlichen Packet-Kommandos ist neben dem Wert auch vom Session Context abhängig:<br>Die folgende Tabelle führt die Bedeutung für den <strong>Empfänger</strong> (!) auf:</p><table>
<thead>
<tr>
<th>Command</th>
<th>received by Client</th>
<th>received by NwServer</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMD_JOIN</td>
<td>no action</td>
<td>GW sends CONFIG: new CfgCHN ID + Pkt ID + Node/GW ID + AppKey</td>
</tr>
<tr>
<td>CMD_REJOIN</td>
<td>Send new JOIN Request to GW</td>
<td>GW sends CONFIG: current(!) assigned CfgCHN ID + Pkt ID + Node/GW ID</td>
</tr>
<tr>
<td>CMD_LOGSTATUS</td>
<td>no action</td>
<td>Forward Frame to AppServer: Process Sensor log data</td>
</tr>
<tr>
<td>CMD_GETSDLOG</td>
<td>Send SDcard data</td>
<td>Forward Frame to AppServer: Process SDCard data</td>
</tr>
<tr>
<td>CMD_RETRY</td>
<td>Send same Pkg again (last pkg was corrupt)</td>
<td>no action</td>
</tr>
<tr>
<td>CMD_ACK</td>
<td>NOP: Ack. for last sent Pkg by GW (except JOIN -&gt; Accept by CONFIG)</td>
<td>NOP: Ack. for last sent Pkg by Node</td>
</tr>
<tr>
<td>CMD_CONFIG</td>
<td>set new CfgChn + Node/GW-ID for next sessions</td>
<td>no action</td>
</tr>
<tr>
<td>CMD_EVENT</td>
<td>no action</td>
<td>Analysiere Eventcode und erzeugte entspr. Aktionen/Meldungen</td>
</tr>
<tr>
<td>CMD_RES7</td>
<td>reserved</td>
<td>reserved</td>
</tr>
<tr>
<td>CMD_RES8</td>
<td>reserved</td>
<td>reserved</td>
</tr>
<tr>
<td>CMD_TIME</td>
<td>no action</td>
<td>Send curr. Server Time Stamp to Node</td>
</tr>
<tr>
<td>CMD_NOP</td>
<td>no Action</td>
<td>send ACK to Node</td>
</tr>
</tbody>
</table><p>Die Kommando-spezifischen Paketinterpretationen werden durch ein Cast der jew. CMD-Typedef Strukur auf beeiotpkg_t erreicht.</p><h3 id="beeiotwan-join"><a name="beeiotwan-join" href="#beeiotwan-join"></a>BeeIoTWAN-JOIN</h3><p>Ein JOIN request muss im Idealfall nur einmal zur Lebenszeit eines Clients abgesetzt werden, und zwar im Anschluss oder während der Setupphase eines Knoten. Ein erfolgreicher JOIN-request des Knotens wird durch ein JOIN Accept Paket: CONFIG durch den NwServer quittiert.</p><p>Voraussetzungen des JOIN requests zur Massnahme folgender Störfalle:</p><ul>
<li>Der GW wurde neu gestartet oder der NwServer fordert den Wechsel zu einem neuen Gateway<ul>
<li>Wurde der GW ohne Recovery seiner Runtime Daten neu gestartet<br>  -&gt; Derselbe Status wie der Wechsel zu einem neuen Gateway: new JOIN</li><li>Der neue Gateway weisst alle Pakete vom Knoten zurück mit der Aufforderung: REJOIN<br>Der Client hat daraufhin einen JOIN request zu stellen (keinen REJOIN !) damit der Gateway eine neue KnotenInstanz intern zur Verwaltung der Paketdaten und Weiterleitung an “wartende” AppServices aufbaut.</li></ul>
</li><li>Der Client wurde neu gestartet<ul>
<li>ohne Recovery (kein Sleep/WakeUp cycle): Der Client stellt einen neuen JOIN request<ul>
<li>Der Gateway erkennt den Knoten an der DevEUI und den gespeicherten JOIN Status<br>Die JOIN Accept Antwort: CONFIG enthält die bisherigen Session daten: GWID/NodeID/CfgChn-ID + AppKey.</li></ul>
</li></ul>
</li></ul><p>Für einen JOIN request hat der Client immer den default ConfigChannel: CC0 sowie die default GW-/Node-IDs: GWIDx und  NODEIDBASE zu verwenden.<br>Ein REJOIN Request muss ebenfalls über dieses Band CC0 und Verwendung der GWIDx erfolgen, die NodeID darf die Aktuelle sein; ansonst wird er abgewiesen.</p><p>Alle der JOIN Session folgenden RX/TX Transfer-Sessions haben über den zugewiesenen Channel unter Verwendung der neuen GW/Node-IDs zu erfolgen, welche im Join-Accept CONFIG Paket seitens des Netzwerkservers mitgeteilt wurden.</p><p>Das (Re-)JOIN Paket hat das Format: beeiot_join_t<br>Der enthaltene (RE-)JOIN Payload (joinpar_t) enthält folgende Angaben:</p><ul>
<li>devEUI -&gt; Eindeutige HW ID des Nodes (i.d.R. von der MAC abgeleitet)</li><li>joinEUI -&gt; eindeutige ID des AppServers mit dem der Client kommunizieren möchte.</li><li>frmid -&gt; App-Daten Payload counter zur Sequentialisierung der gesendeten App-Datenpakete</li><li>vmajor+vminor -&gt; die seitens Client unterstützte BIoTWAN Version (Der NwServer entscheidet dann, ob er die Version unterstützt)</li></ul><p>Das JOIN Protokoll hat folgenden Verlauf:</p><ol>
<li>Erzeuge das JOIN Paket<br> a) CMD_JOIN: BIOT_JOIN + default GWID &amp; NODEIDBASE + JOINEUI + DEVEUI<br> b) CMD_REJOIN: BIOT_JOIN + current NODEID + GWID + JOINEUI + DEVEUI</li><li>Create new MIC of Frame-Header + payload</li><li>Send Paket in ACK Wait Mode</li><li>Switch to RX Mode: Wait for BeeIotRXFlag (from ISR) set in case of a received CONFIG package<br> a) If Max numbers of overall JOIN Requests reached -&gt; double Wait/sleep time<br> b) If CONFIG Wait TimeOut reached -&gt; initiate JOIN Send retry<br>   -&gt; If max # of retries reached goto to sleep mode and give up<br> c) if CONFIG package received -&gt; start Parsing of CONFIG Data BIoTParseCfg()</li><li>If CONFIG package is valid -&gt; Set new Channel-onfig and Modem Status = BIoT_IDLE</li></ol><p>Jetzt ist das LoRa Modem bereit reguläre Datenpakete an den Server zu senden.<br>Die Datenpakete werden gatewayseitig an den im Join Request angegebenen JOINEUI APP-Prozess weitergeleitet und prozessiert.</p><h3 id="client-tx/rx-sessions"><a name="client-tx/rx-sessions" href="#client-tx/rx-sessions"></a>Client TX/RX Sessions</h3><p>Zu einer Standard TX session gehört folgendes Kommando: CMD_LOGSTATUS<br>Das Flussprotokoll besteht aus 3 Hauptphasen:</p><ol>
<li>Senden des LoraLog Status an den Gateway</li><li>Empfang des Antwortpaketes</li><li>Ggfs. Empfang eines RX1 Paketes vom GW mit einem Opt. Zusatzkommando<br> -&gt; z.B. GetSDLog, FWUpdate</li></ol><p><img src="images_v2/BeeIoT_PkgFlowCtrl.jpg"></p><p>Die Client Funktion LoraLog() erzeugt das Kommandopaket demnach:</p><ol>
<li>Converts UserLog-String into LoRa Message format</li><li>Controls BIoTWAN flow control: Send -&gt; Wait for Ack … and in case send retries:<ol>
<li>Check of valid LoRa Modem Send Status: BIOT_IDLE (if not try to recover status)</li><li>Prepare TX package with LogStatus data</li><li>Store TX Session data for ISR and retry loops</li><li>Initiate TX session</li><li>Bypass FlowControl in NoAck Mode</li><li>Start of ACK wait loop<br> a. Activate flow control: start RX Contiguous Mode<br> b. Check for ACK Wait Timeout<br> c. No ACK received -&gt; initiate a retry loop</li><li>Max. # of Retries reached -&gt; give up (-99)<br> -&gt; Goto Sleep Mode and set REJOIN status</li><li>Start RX1 Window: TX session Done (ACK received) Give GW the option for another Job</li><li>Check for ACK Wait Timeout -&gt; yes, but no RX1 job expected =&gt; Done(=0)</li><li>Either RX1 job received or RETRY / REJOIN as Ack from previous TX session</li><li>BIoTParse() RX-Queue pkg: ISR has checked Header and copied pkg into MyRXData[RXPkgSrvIdx]<br>-&gt; CMD_RETRY:  TX pkg will be sent again -&gt; RX1 loop will wait for ACK<br>-&gt; CMD_REJOIN: BIoTStatus = JOIN  -&gt; RX1 loop ends<br>-&gt; new RX1 CMD: will be processed as usual (ACK wait loop)</li><li>Process (RE-)JOIN Request from GW</li></ol>
</li></ol><p>Entgegen dem LoRaWAN Protokoll kann im BIoTWAN Protokoll sowohl Client wie Gateway-seitig auf ein Fehlerhaftes TX protokoll reagiert werden:<br>Client-seitig: im Falle eines ACH-Timeouts =&gt; Retry Send des TX Paketes<br>GW-seitig: im Falle eines korrupten Payloads (Inhalte oder Länge) -&gt; Request RETRY</p><p>Im Falle eines korrupten Paketheaders reagiert der Gateway nicht (er hat keine validen Senderangaben -&gt; Client läuft auf ACK Timeout und initiiert seinerseits den Send-Retry.</p><p>Da der Client als protokoll-Masetr auftriit bekommt der Gateway durch das nachfolgende RX1-Empfangsfenster die Gelegenheit seinerseits eine Aktion beim Client auszulösen. Spricht clientseitig etwas dagegen (z.B. der Batteriestatus)<br>so kann er auch “verweigern” -&gt; GW läuft auf Timeout.</p><h3 id="der-gateway/server-empfangsstack"><a name="der-gateway/server-empfangsstack" href="#der-gateway/server-empfangsstack"></a>Der Gateway/Server Empfangsstack</h3><p>Der Gateway/Server Stack ist dafür vorbereitet von verschiedenen Clients(Nodes) Pakete zu empfangen. Abhängig von der vorhergehenden Registrierung des Nodes beim Gateway (via JOIN Request) werden ensprechende AppServices angerufen, die FrameDaten weiter zu prozessieren:</p><p><img src="images_v2/BeeIoT_SrvModules.jpg"></p><p>Die elementaren Grundfunktionen sowie alle Services wurden als separate Klassen deklariert und definitiert, die über ihre Zustände und Memberfunktionen interagieren:</p><pre class="cpp hljs"><code class="cpp" data-origin="<pre><code class=&quot;cpp&quot;>main()  -&amp;gt; init_all()               init gwset[mid]= mset[mid=0..cfgini-&amp;gt;loranumchn]
                                    Instanziierung aller ben. Klassen und Verwaltung in gwset[]
        -&amp;gt; setmodemcfg()            cfgini -&amp;gt; gwset[mid].iopins
        -&amp;gt; NwNodeScan()             call NwS scanning routine: forever) polling of all
                                    modems for input pkg.
Class Member Fkt.:
==================
Radio   -&amp;gt; setchannelcfg()          set mset.chncfg from cfgchntab[cfgidx]
        -&amp;gt; resetModem()             activate RST line
        -&amp;gt; getchiptype()            ident. Modem chip
        -&amp;gt; setLoraMode()            set SX-LoraMode register flag
        -&amp;gt; configChannelFreq()      set SX-Frequency register
        -&amp;gt; configLoraModem()        set SX-LoraCfg register 1-3
        -&amp;gt; radio_init()             Fill Random data field, set IRQ Flag Mask
        -&amp;gt; isr_init()               assign ISR fucntion to IRQ line
        -&amp;gt; myradio_irq_handler()
            -&amp;gt; MsgBuffer()          create new MsgBuffer containing Lora Package data
            -&amp;gt; PushMsg()            moves MsgBuffer to MsgQueue

MsgQueue -&amp;gt; Size()/Push()/Pop()     provides FiFo queue (of MsgBuffer elements)
                                    based on std:queue (from STL)
        -&amp;gt; getMsg()                 Ptr. on Queue-&amp;gt;MsgBuffer for Rd/Wr activities

MsgBuffer-&amp;gt; setpkgfifo()            fill MsgContainer with LoRa FiFo raw data frame
        -&amp;gt; setmsghd()               fill MsgBuffer header with RX/Node/Modem info:
                                    rssi/snr/mid/...
NwSrv   -&amp;gt; init NDB[]
        -&amp;gt; set gwset[mid].modem     for mid=0..nmodem    mactive=final # of new modems
        -&amp;gt; set gwset[mid].gwq
        -&amp;gt; MsgQueue()               init empty MsgQueue::queue
        -&amp;gt; NwNodeScan()             central Network Scan Service for all modems
            -&amp;gt; poll 'MsgQueue for len&amp;gt;0'
            -&amp;gt; JS_validatePkg()     validate new MsgBuffer
            -&amp;gt; BeeIoTParse()        parse MsgBuffer for BIoT Commands
                -&amp;gt; AppProxy()       call assigned BIoTApp for further/final Msg data processing
            -&amp;gt; PopMsg()             removes first Msg in MsgQueue

JoinSrv -&amp;gt; JS_ValidatePkg()         validate Node identity &amp;amp; pkg header values
                                    for BIoT conformity
        -&amp;gt; JS_RegisterNode()        new Node: setup NDB[ndid] by WLTab[ndid]
                                    and gwset[mid] parameters

AppSrv  -&amp;gt; AppProxy() -&amp;gt; AppBIoT()  call BeeHive Mon.-App-Function depending on
                                    AppEUI assigned to node
                      -&amp;gt; BeeCSV()   Forward LogData in CSV format to Web Space for WebApp
                      -&amp;gt; AppGH()    call GreenHouse monitoring App-Function
                      -&amp;gt; AppTurtle()call TurtleHouse monitoring App-Function
</code></pre>">main()  -&gt; init_all()               init gwset[mid]= mset[mid=0..cfgini-&gt;loranumchn]
                                    Instanziierung aller ben. Klassen und Verwaltung in gwset[]
        -&gt; setmodemcfg()            cfgini -&gt; gwset[mid].iopins
        -&gt; NwNodeScan()             call NwS scanning routine: forever) polling of all
                                    modems for input pkg.
Class Member Fkt.:
==================
Radio   -&gt; setchannelcfg()          set mset.chncfg from cfgchntab[cfgidx]
        -&gt; resetModem()             activate RST line
        -&gt; getchiptype()            ident. Modem chip
        -&gt; setLoraMode()            set SX-LoraMode register flag
        -&gt; configChannelFreq()      set SX-Frequency register
        -&gt; configLoraModem()        set SX-LoraCfg register 1-3
        -&gt; radio_init()             Fill Random data field, set IRQ Flag Mask
        -&gt; isr_init()               assign ISR fucntion to IRQ line
        -&gt; myradio_irq_handler()
            -&gt; MsgBuffer()          create new MsgBuffer containing Lora Package data
            -&gt; PushMsg()            moves MsgBuffer to MsgQueue

MsgQueue -&gt; Size()/Push()/Pop()     provides FiFo queue (of MsgBuffer elements)
                                    based on std:queue (from STL)
        -&gt; getMsg()                 Ptr. on Queue-&gt;MsgBuffer for Rd/Wr activities

MsgBuffer-&gt; setpkgfifo()            fill MsgContainer with LoRa FiFo raw data frame
        -&gt; setmsghd()               fill MsgBuffer header with RX/Node/Modem info:
                                    rssi/snr/mid/...
NwSrv   -&gt; init NDB[]
        -&gt; set gwset[mid].modem     for mid=0..nmodem    mactive=final # of new modems
        -&gt; set gwset[mid].gwq
        -&gt; MsgQueue()               init empty MsgQueue::queue
        -&gt; NwNodeScan()             central Network Scan Service for all modems
            -&gt; poll 'MsgQueue for len&gt;0'
            -&gt; JS_validatePkg()     validate new MsgBuffer
            -&gt; BeeIoTParse()        parse MsgBuffer for BIoT Commands
                -&gt; AppProxy()       call assigned BIoTApp for further/final Msg data processing
            -&gt; PopMsg()             removes first Msg in MsgQueue

JoinSrv -&gt; JS_ValidatePkg()         validate Node identity &amp; pkg header values
                                    for BIoT conformity
        -&gt; JS_RegisterNode()        new Node: setup NDB[ndid] by WLTab[ndid]
                                    and gwset[mid] parameters

AppSrv  -&gt; AppProxy() -&gt; AppBIoT()  call BeeHive Mon.-App-Function depending on
                                    AppEUI assigned to node
                      -&gt; BeeCSV()   Forward LogData in CSV format to Web Space for WebApp
                      -&gt; AppGH()    call GreenHouse monitoring App-Function
                      -&gt; AppTurtle()call TurtleHouse monitoring App-Function
</code></pre><h4 id="radio-service---class-radio"><a name="radio-service---class-radio" href="#radio-service---class-radio"></a>Radio Service - class Radio</h4><p>Der <em>Radio Service</em> empfängt die rohen LoRa-Pakete. Dabei werden in der ISR Routine myradio_irq_handler() verschiedene Checks des Paketheaders durchgeführt:</p><ol>
<li>Check LoRa Mode    -&gt; BIOT use only LoRa Modem type<ol>
<li>Check TXMode    -&gt; set BeeIotTXFlag flag only =&gt; done.</li><li>Check RXMode &amp; IRQ-RXDone Flag</li><li>CRC Check    -&gt; shortcut ISR, no action</li><li>a)Get RSSI &amp; SNR Status and<br>b) evaluate SNR threshold<br>-&gt; if &lt; SNR Threshold =&gt; shortcut ISR</li><li>Check Package size: must be in range of BeeIoT WAN protocol specification</li><li>Create new MsgQueue Buffer -&gt; Copy LoRa FiFo data to RX Queue buffer</li><li>RXTOUT-Check      -&gt; shortcut ISR, no action (BIoT uses RXCont Mode only)</li><li>Acknowledge all IRQ flags at once</li></ol>
</li><li>FSK Mode IRQ =&gt; should never happen ! -&gt; shortcut ISR, no action</li><li>Set OPMode to Sleep Mode -&gt; OM polled by BIoT Log Service</li></ol><p>Das Semaphor der MsgQueue wird durch den Längenzähler der MsgQueue realisiert:<br>Die Länge ist 0 wenn sich kein gefülltes Datenpaket in der MsgQueue befindet.<br>Der Wert &gt;0 gibt die Anzahl der eingetragenen MsgBuffer (Pakete) an.<br>Da älteste Paket steht am Anfang -&gt; FiFo Reihefolge der Paketbearbeitung. Neue Pakete werden hinten angehängt.</p><h4 id="network-service---class-nwsrv"><a name="network-service---class-nwsrv" href="#network-service---class-nwsrv"></a>Network Service - class NwSrv</h4><p>Der <em>NetworkServer</em> koordiniert den BIoTWAN Protokollfluss.<br>Dazu wird in NwNodeScan() dauerhaft eine Loop im RX-Contiguous Mode durchlaufen, während dieser die MsgQueue Länge auf &gt;0  gepolled wird. GetMsg() liefert und PoPMsg() entfernt das “älteste” nicht bearbeitete Queue Element.</p><p>Wurde ein Paket empfangen (MsgQueue.Size &gt; 0) wird das MsgBuffer Paketder Parsingroutine BeeIoTParse() übergeben.</p><p>Dort wird zunächst der Paket-Sender (Node) sowie der Paket Header durch eine Anfrage an den JOIN Service validiert: JS_ValidatePkg().</p><p>Bei Akzeptanz wird die aktuell zum Paket sendenden Clients gespeicherte MSG-ID mit der des Paketes verglichen. Ist er identisch wird das empfangene Paket als Duplikat verworfen (z.B. im Falle eines erfolgreich empfangenen Paketes mit anschliessend versendetem ACK Paketes, welches den Client aber nicht erreicht hat). Ist die empfangene MSG-ID kleiner als die gespeicherte, kann es sich um eine Man-In-the-middle Attack handeln. Ist die MSG-ID größer wird das Paket akzeptiert.<br>Anschliessend wird der CMD-Code geprüft. Network-Service Commandos werden sofort in der NWS-Service BeeIoTFlow-Routine bearbeitet: NOP, (RE-)JOIN, ACK, CONFIG.<br>Application Commands werden an den zugewiesenen Application-Service via AppSrv.AppProxy() übergeben: z.B. LOGSTATUS, GETSDLOG, FWUPD.</p><h4 id="join-service---class-joinsrv"><a name="join-service---class-joinsrv" href="#join-service---class-joinsrv"></a>JOIN Service - class JoinSrv</h4><p>Der <em>JOIN-Service</em> evaluiert die Client JOIN Request Anfragen, indem er alle Headerparameter auf ihre Werte konform zu BIoTWan.h prüft nd ob ein Knoten bekannt ist (via WLTab[]).<br>Im JOIN Erfolgsfall erst werden alle weiteren Session Pakete dieses CLients zugelassen.</p><p>Aus Security-Gründen kann nur ein serverseitig bekannter registrierter DevEUI Clientcode im JOIN Prozess akzeptiert werden. Dazu führt der JOIN Service eine interne Node-Referenztabelle: WLTab[] in der die zu vergleichende Referenz-DevEUI geführt wird. Diese WLTab[] wird in der Init-Phase aus der config.ini Datei mit User-Setup-Angaben gespeisst.</p><p>Im Falle eines JOIN-Hits wird der entsprechende WLTab[]-Index auch gleichzeitig als Index für die, allen Services zugänglichen, Nodelist-Table: JoinSrv.NDB[] hergenommen. AUs diesem NDB-index + der NODEIDBASE wird der neue Node-Index gebildet: NODEIDBASE+ndid, der im CONFIG-Answer-Paket an den Client zurückübermittelt wird.<br>Fortwährend hat der Client diese NodeID zu verwenden, bis zu einem erneuten JOIN Request, der auch im Falle eines Roamingversuchs anfallen könnte, was eine neue NodeID zur Folge haben könnte (aber immer mit dergleichen DevEUI).</p><p>Der JOIN Service füllt den NDB[ndid]-Eintrag des jeweilgen angemeldeten Clients mit allen bekannten Initialisierungsdaten zur weiteren Session-Bearbeitung durch den Network- und Application Service.</p><p>Erkennt der Network Service ein Application Service Kommando so wird der dazugehörige MsgBuffer-Frame dem AppSrv.AppProxy() übergeben:<br>Diese AppProxy() Funktion verwaltet eine interne JOIN-EUI Referenztabelle: TJoinEUI[].<br>Im Falle eines Hits der JOINEUI aus dem Node-JOIN Request -&gt; liefert derselbe Index in einer switch Struktur zum Applikationsaufruf und damit zur Weiterleitung des Paket-Frame-Payloads an die Application-Routine.</p><h4 id="application-services---class-appsrv"><a name="application-services---class-appsrv" href="#application-services---class-appsrv"></a>Application Services - class AppSrv</h4><p>Über den Application-Proxy können somit verschiedenste Clienttypen zu ihren Applikationsdiensten dynamisch via JOIN request geroutet werden (ähnlich einer TCP-Bind Funktion). Dazu muss die Applikation nur mit ihrer AppEUI(=JOINEUI) in der TJoinEUI[] eingetragen sein.</p><p>Für den BeeIoT Client einer Bienen-Stockwaage steht z.B. die Funktion: AppBIoT() bereit. Dort wird der Frame-Payload entschlüsselt und die Sensorlogdaten erneute geparsed. STimmen die Daten und deren Format, kann das LOGSTATUS Paket per ACK bestätigt werden. Ansonsten kann der Application Service anstelle des ACK ein RETRY anfordern.</p><p>Erfolgreich validierte Daten werden über AppSrv.beecsv() in das Format einer CSV Datei gewandelt und der CSV-LogDatei übergeben. Diese kann zeitgleich von einem Webservice interpretiert und zur Graphendarstellung genutzt werden.<br>Alternativ kann diese CSV Datei auch per curl()-FTP an einen externen (Web-) Service zur Weiterverarbeitung (AppSrv.beelog()) übermittelt werden.</p><p>Am Ende der Bearbeitung kann der Applikations-Service auch einen Vorschlag für ein RX1 Paket stellen (rc=1), welches als 2. Antwort im RX1 Window an den Client zurückgesendet wird.</p><h2 id="biot-command-interface"><a name="biot-command-interface" href="#biot-command-interface"></a>BIOT Command Interface</h2><p>Ein File basiertes Kommandointerface erlaubt das Absetzen von EInzelkommandos selektiv an einzelne Nodes. Die Node Selektion findet über die Node ID statt.</p><p>In der Config.ini Datei der Section <em>[BeeIOT]</em> finden sich die Definitionen für die relevanten Interface files:</p><pre class="cpp hljs"><code class="cpp" data-origin="<pre><code class=&quot;cpp&quot;>CMDFILE         = beecmd.txt        ; Command file for RX1 response window
RESULTFILE      = beeresult.txt     ; Result data from RX1-command
</code></pre>">CMDFILE         = beecmd.txt        ; Command file <span class="hljs-keyword">for</span> RX1 response window
RESULTFILE      = beeresult.txt     ; Result data from RX1-command
</code></pre><p>Diese Dateien werden unter <em>BEEIOTWEB</em>-Path gesucht (wo auch die CSV datei aktualisiert wird.)</p><p>In dem <strong>CMDFile</strong> werden Node spezifische Kommandos in folgendem Format erwartet:<br><strong>    [nodeid] [cmd] [par1] [par2] [par3] </strong><br>Beispiel: 4: SD 1 1 0<br>Die dazugehörige Paketstruktur ist in BIotWan.h definiert: <em>beeiot_cmd_t</em></p><table>
<thead>
<tr>
<th>Item</th>
<th>Beschreibung</th>
<th>Range</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td>[nodeid]</td>
<td>Die NodeID des ausgewählten Devices:</td>
<td>1 .. 9</td>
<td>(wird Prg.intern um die NODEIDBASE erweitert)</td>
</tr>
<tr>
<td>[cmd]</td>
<td>2 Zeichen Kürzel für das CMD_xxx Kommando</td>
<td></td>
<td>Klein- oder Grossschrift erlaubt; aber kein mix.</td>
</tr>
<tr>
<td></td>
<td>SX: Request SD card directory string</td>
<td>SX/sx</td>
<td></td>
</tr>
<tr>
<td></td>
<td>SD: Request SD card LogData string</td>
<td>SD/sd</td>
<td></td>
</tr>
<tr>
<td></td>
<td>RS: Reset Node to JOIN MOdequest SD card directory string</td>
<td>RS/rs</td>
<td></td>
</tr>
<tr>
<td>[par1..3]</td>
<td>optionale Parameter per Kommando</td>
<td>0..255</td>
<td>unint8_t Typ</td>
</tr>
</tbody>
</table><ul>
<li><p><strong>[SX/sx]:</strong> liefert die Darstellung der Directory Struktur. Dabei werden die jeweiligen Directory-Ebenen und deren gefundene Files als jeweilige Text Strings zeilenweise übertragen. In der Paketstruktur beeiot_sddir_t  liefert ein Index: <em>sddir_seq</em> den Zeilenindex der übertragenen Strings. 0xFF markiert generell die letzte übertragene Zeile.</p>
<ul>
<li><strong>Par1</strong> definiert das rekursive Directory level bis wo gesucht wird.<ul>
<li>1: ‘/‘ Root directory</li><li>2..n: weitere Sub Folder Ebenen.</li></ul>
</li><li><strong>Par2</strong> Anzahl der zu übertragenen Folder-Strings -&gt; Limit für <em>sddir_seq</em></li><li><strong>Par3</strong> not used</li><li>Die dazugehörige Result-Paketstruktur ist in BIotWan.h definiert: <em>beeiot_sddir_t</em><br>Die maximale String Länge BIoT_FRAMELEN errechnet sich  (incl EOL) aus:<ul>
<li>MAX_PAYLOAD_LENGTH - BIoT_HDRLEN - sddir_seq-length - BIoT_MICLEN</li><li>also ca. 128 - 6 - 1 - 4 = 117 Byte (bei BIotWanh.h Version V1.7) </li></ul>
</li><li>Die Daten Strings werden sequentiell in der unter RESULTFILE definierten Datei abgelegt.</li><li>Die CMDFILE Datei wird nach erfolgreich Übertragung vollständig gelöscht.</li></ul>
</li><li><p><strong>[SD/sd]</strong> liefert den Inhalt der SDLOGPATH Datei (siehe beeiot.h): “/logdata.txt”</p>
<ul>
<li>Diese wird bei jedem Sample um die Sensordaten aktualisiert inkl. aller internen Messages, welche ev. zu groß zur stetigen Übertragung sind. Dabei werden die jeweiligen Datenzeilen als Text/Binär Strings übertragen (so wie abgelegt im DSensor2/DataMessage Mode).</li><li>In der Paketstruktur beeiot_sd_t  liefert ein 2-ByteIndex: ‘sdseq_msb + sdseq_lsb’ den Zeilenindex der übertragenen Daten-chunka. 0xFFFF markiert den letzten übertragenen Daten blocks.</li><li><strong>Par1</strong> Anzahl der zu übertragenen Data-Chunks -&gt; Limit für <em>sdseq counter</em></li><li><strong>Par2</strong> not used</li><li><strong>Par3</strong> not used</li><li>Die dazugehörige Result-Paketstruktur ist in BIotWan.h definiert: <em>beeiot_sd_t</em><br>Die maximale Daten-Chunk Länge (binary, kein EOL Marker !) BIoT_FRAMELEN errechnet sich aus:<ul>
<li>MAX_PAYLOAD_LENGTH - BIoT_HDRLEN - 2-Byte-sdseq_seq - BIoT_MICLEN</li><li>also ca. 128 - 6 - 2 - 4 = 116 Byte (bei BIotWanh.h Version V1.7)</li></ul>
</li><li>Die Daten Chunks werden sequentiell in der unter RESULTFILE definierten Datei abgelegt.</li><li>Die CMDFILE Datei wird nach erfolgreich Übertragung vollständig gelöscht.</li><li>Beispiel: ‘4: sd 16 0 0’</li></ul>
</li><li><strong>[RS/rs]</strong> Reset Node Transfer Statistics, enter JOIN Mode, Reset SD Card.<ul>
<li><strong>Par1</strong> Reset Node Level: 1: All (Lora + SD), 2: Lora only</li><li><strong>Par2</strong> SD Reset level =1: LogPath-file, =2: Directory</li><li><strong>Par3</strong> not used</li><li>Die CMDFILE Datei wird nach erfolgreich Übertragung vollständig gelöscht.</li><li>Beispiel: ‘4: rs 1 1 0’</li></ul>
</li></ul><h2 id="logging"><a name="logging" href="#logging"></a>Logging</h2><p>Sowohl im CLient wie auf Server Seite ist derselbe Logging mechanismus über ein 16 Bit Flagfeld eingerichtet: <strong>lflags</strong>.<br>Diese globale variable ist für alle Codebereiche gleichermaßen erreichbar und wird über ein inline Macro LOGBH evaluiert.</p><p>Zum Setup-Zeitpung wird das lflags-feld getrennt initialisiert.<br>In der Init-Phase auf Server-Seite wird nach dem config.ini Parsing ein Custom-Value für das Flagfeld nachgeladen und überschreibt zunächst serverseitig den ‘VerboseMode’.<br>Erst im Antwort-Paket eines JOIN Requests wird dieses 16-Bit Flagfeld als Verbosemode auch zum CLient übertragen und dann dort aktiviert.<br>In Kombination mit einem SDLOG-Data Kommando, welches das auslesen von SDCard bereichen ermöglichen soll, könnte man temporär bei Störungen Log-Phasen auf bestimmte Funktionsbereiche aktivieren und remote auch wieder auslesen.</p><p>Setzt man lflags auf 65535 (=0xFFF) werden alle Logmeldungen ausgegeben:</p><p>Ein LogDump könnte wie folgt aussehen (MIC und NWKeys sind nicht hier aktiviert):</p><pre class="cpp hljs"><code class="cpp" data-origin="<pre><code class=&quot;cpp&quot;>st:0x5 (DEEPSLEEP_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
configsip: 0, SPIWP:0xee
clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00
mode:DIO, clock div:2
load:0x3fff0018,len:4
load:0x3fff001c,len:1044
load:0x40078000,len:8896
load:0x40080400,len:5828
entry 0x400806ac
Evaluate Wakeup reason - BootCnt: 0 - Intervall 60
Wakeup caused by timer
  Setup: Init runtime config settings
  Setup: Init RTC Module DS3231   RTC: Temperature: 23.50 °C, SqarePin switched off
  RTC: STart RTC Test Output ...
2020/3/29 (Sunday) 14:9:32
 since midnight 1/1/1970 = 1585490972s = 18350d
 now + 7d + 30s: 2020/4/6 2:39:38

  RTC: Get RTC Time: 2020-03-29T14:09:32 - 2020-03-29 - 14:09:32
  Setup: SPI Devices ...
  MSPI: VSPI port for 3 devices
  MSPI: SPI-Init of SD card...  MSPI: SD Card mounted
  MSPI: SPI-Init: ePaper EPD part1 ...
  Setup: HX711 Weight Cell
  HX711: init Weight cell ADC port
  HX711: Offset(raw): 297570 - Unit(raw): 44000 per kg
  Setup: ADS11x5
  ADS: Init I2C-port incl. Alert line
  Setup: Wifi in Station Mode
  Setup: Wifi setup failed
  Setup: No WIFI no NTP-Time.
  RTC: Get RTC Time: 2020-03-29T14:09:32 - 2020-03-29 - 14:09:32
  NTP: BHDB updated by RTC time
  Setup: SD Card
  SD: SD Card Type: SDSC - Size: 1938MB
  SD: File /logdata.txt found
  Setup: LoRa SPI device &amp;amp; Base layer
  LoRa: WakeUpMode:1 in Status: JOIN
  LoRaCfg: Set Modem/Channel-Cfg[0]: 868100000Mhz, SF=7, TXPwr:14, BW:125000, CR:5, LPreamble:12 
    SW:0x12, CRC, noInvIQ  LoraCfg: StdBy Mode
  LoRa: assign ISR to DIO0  - default: GWID:0x98, NodeID:0x80
  Setup: OneWire Bus setup
  OWBus: Init OneWire Bus
  OWBus: Locating devices...Found 0 devices.
    Device 0: Int-Address: 28201F8E1F130185  DS18B20
    Device 1: BH. Address: 28AAE46D1813022F  DS18B20
    Device 2: Ext.Address: 28AACA6A181302F3  DS18B20
  OWBus: Current Sensor Resolution: 12
  OWBUS: set sensor resolution: 12
  OWBus: Requesting temperatures...
  OWBus: Int.Temp.Sensor (°C): 20.81
  OWBus: Bee.Temp.Sensor (°C): 19.44
  OWBus: Ext.Temp.Sensor (°C): 20.31
  Setup: ePaper + show start frame 
  SetinKey: EPD-Key1 reserved by Boot Funktion of DevKitC Board
  SetinKey: EPD-Key1 reserved by Reset Funktion of DevKitC Board
  SetinKey: EPD-Key3 reserved by Bee-DIO2 Funktion of SX1276
  SetinKey: EPD-Key4 ISR assigned
  Setup: ePaper Test failed
Setup Phase done

  RTC: Get RTC Time: 2020-03-29T14:09:33 - 2020-03-29 - 14:09:33
  NTP: BHDB updated by RTC time
&amp;gt;*******************************************&amp;lt;
&amp;gt; Start next BeeIoT Weight Scale loop
&amp;gt; Loop# 14  (Laps: 3, BHDB[2]) 2020-03-29 14:09:33
&amp;gt;*******************************************&amp;lt;
  Loop: Weight(raw) : -300027 - Weight(unit): -6.819 kg
  OWBus: Init OneWire Bus
  OWBus: Locating devices...Found 3 devices.
    Device 0: Int-Address: 28201F8E1F130185  DS18B20
    Device 1: BH. Address: 28AAE46D1813022F  DS18B20
    Device 2: Ext.Address: 28AACA6A181302F3  DS18B20
  OWBus: Current Sensor Resolution: 12
  OWBUS: set sensor resolution: 12
  OWBus: Requesting temperatures...
  OWBus: Int.Temp.Sensor (°C): 20.81
  OWBus: Bee.Temp.Sensor (°C): 19.56
  OWBus: Ext.Temp.Sensor (°C): 20.50
  Loop: ADSPort(0-3): 
  ADS: Single-ended read from AIN0: 3.28V - 
  ADS: Single-ended read from AIN1: 4.67V - 
  ADS: Single-ended read from AIN2: 4.06V (91%) - 
  ADS: Single-ended read from AIN3: 2.54V
  Loop[14]: 2020-03-29 14:09:33,-6.82,20.50,20.81,19.56,23.50,3.28,5.08,4.67,4.06,91#14 o.k.
  Log: No SDCard, no local Logfile...
  LoRaLog: BeeIoTStatus = JOIN
  BeeIoTJoin: Start searching for a GW
  BIoT_getmic: Add MIC[4] = 11 22 33 44 for Msg[255]
  LoRaCfg: Set Modem/Channel-Cfg[0]: 868100000Mhz, SF=7, TXPwr:14, BW:125000, CR:5, LPreamble:12     
    SW:0x12, CRC, noInvIQ  LoraCfg: StdBy Mode
  LoRaSend: TXData &amp;lt;PkgLen= 29By&amp;gt;
  sendMessage: Start TX
  LoRaSend(0x80&amp;gt;0x99)[255](cmd=0) &amp;lt;FrmLen: 20By&amp;gt;
MSGfield at 0x3FFC03F0:
Address:  0 1  2 3  4 5  6 7   8 9  A B  C D  E F  length= 29 Byte
  +   0: 9980 FF00 14DC 8AD5  FFFE 286F 24BB EEEE  &amp;lt;..........(o$...&amp;gt;
  +  10: BBEE EECC EE00 0B01  0011 2233 44         &amp;lt;..........&quot;3D&amp;gt;
  BeeIoTJoin: waiting for RX-CONFIG Pkg. in RXCont mode:oo
onReceive: got Pkg: len 0x19
MSGfield at 0x3FFC0470:
Address:  0 1  2 3  4 5  6 7   8 9  A B  C D  E F  length= 5 Byte
  +   0: 8099 FF06 10                              &amp;lt;.....&amp;gt;
onReceive: RX(0x99&amp;gt;0x80)[255]:(cmd=6: CONFIG) DataLen=16 Bytes
  BeeIotJoin: RX pkg received: CONFIG
  BeeIotJoin: RX Queue Status: SrvIdx:0, IsrIdx:1, new PkgID:255, RXFlag:1
  BeeIoTParse[255]: cmd= CONFIG -&amp;gt; switch to new channel cfg.
  BeeIoTParseCfg: New Configuration: BIoT-Interval: 600sec., Verbose:513, ChIndex:0, NDID:0x81, GwID:0x98, MsgCnt:0
  Lora: Joined! New: GWID:0x98, NodeID:0x81, msgcount:0
    DEVEUI: 0x-DC-8A-D5-FF-FE-28-6F-24
   JOINEUI: 0x-BB-EE-EE-BB-EE-EE-CC-EE
  LoRaLog: wait for incoming ACK in RXCont mode (Retry: #0)..
onReceive: RX(0x98&amp;gt;0x81)[1]:(cmd=5: ACK) DataLen=0 Bytes

  LoRaLog: wait for add. RX1 Pkg. (RXCont):oooooo None.

  Main: Going to Deep Sleep - Trigger: Timer only(600 sec.)
</code></pre>">st:0x5 (DEEPSLEEP_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
configsip: 0, SPIWP:0xee
clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00
mode:DIO, clock div:2
load:0x3fff0018,len:4
load:0x3fff001c,len:1044
load:0x40078000,len:8896
load:0x40080400,len:5828
entry 0x400806ac
Evaluate Wakeup reason - BootCnt: 0 - Intervall 60
Wakeup caused by timer
  Setup: Init runtime config settings
  Setup: Init RTC Module DS3231   RTC: Temperature: 23.50 °C, SqarePin switched off
  RTC: STart RTC Test Output ...
2020/3/29 (Sunday) 14:9:32
 since midnight 1/1/1970 = 1585490972s = 18350d
 now + 7d + 30s: 2020/4/6 2:39:38

  RTC: Get RTC Time: 2020-03-29T14:09:32 - 2020-03-29 - 14:09:32
  Setup: SPI Devices ...
  MSPI: VSPI port for 3 devices
  MSPI: SPI-Init of SD card...  MSPI: SD Card mounted
  MSPI: SPI-Init: ePaper EPD part1 ...
  Setup: HX711 Weight Cell
  HX711: init Weight cell ADC port
  HX711: Offset(raw): 297570 - Unit(raw): 44000 per kg
  Setup: ADS11x5
  ADS: Init I2C-port incl. Alert line
  Setup: Wifi in Station Mode
  Setup: Wifi setup failed
  Setup: No WIFI no NTP-Time.
  RTC: Get RTC Time: 2020-03-29T14:09:32 - 2020-03-29 - 14:09:32
  NTP: BHDB updated by RTC time
  Setup: SD Card
  SD: SD Card Type: SDSC - Size: 1938MB
  SD: File /logdata.txt found
  Setup: LoRa SPI device &amp; Base layer
  LoRa: WakeUpMode:1 in Status: JOIN
  LoRaCfg: Set Modem/Channel-Cfg[0]: 868100000Mhz, SF=7, TXPwr:14, BW:125000, CR:5, LPreamble:12 
    SW:0x12, CRC, noInvIQ  LoraCfg: StdBy Mode
  LoRa: assign ISR to DIO0  - default: GWID:0x98, NodeID:0x80
  Setup: OneWire Bus setup
  OWBus: Init OneWire Bus
  OWBus: Locating devices...Found 0 devices.
    Device 0: Int-Address: 28201F8E1F130185  DS18B20
    Device 1: BH. Address: 28AAE46D1813022F  DS18B20
    Device 2: Ext.Address: 28AACA6A181302F3  DS18B20
  OWBus: Current Sensor Resolution: 12
  OWBUS: set sensor resolution: 12
  OWBus: Requesting temperatures...
  OWBus: Int.Temp.Sensor (°C): 20.81
  OWBus: Bee.Temp.Sensor (°C): 19.44
  OWBus: Ext.Temp.Sensor (°C): 20.31
  Setup: ePaper + show start frame 
  SetinKey: EPD-Key1 reserved by Boot Funktion of DevKitC Board
  SetinKey: EPD-Key1 reserved by Reset Funktion of DevKitC Board
  SetinKey: EPD-Key3 reserved by Bee-DIO2 Funktion of SX1276
  SetinKey: EPD-Key4 ISR assigned
  Setup: ePaper Test failed
Setup Phase done

  RTC: Get RTC Time: 2020-03-29T14:09:33 - 2020-03-29 - 14:09:33
  NTP: BHDB updated by RTC time
&gt;*******************************************&lt;
&gt; Start next BeeIoT Weight Scale loop
&gt; Loop# 14  (Laps: 3, BHDB[2]) 2020-03-29 14:09:33
&gt;*******************************************&lt;
  Loop: Weight(raw) : -300027 - Weight(unit): -6.819 kg
  OWBus: Init OneWire Bus
  OWBus: Locating devices...Found 3 devices.
    Device 0: Int-Address: 28201F8E1F130185  DS18B20
    Device 1: BH. Address: 28AAE46D1813022F  DS18B20
    Device 2: Ext.Address: 28AACA6A181302F3  DS18B20
  OWBus: Current Sensor Resolution: 12
  OWBUS: set sensor resolution: 12
  OWBus: Requesting temperatures...
  OWBus: Int.Temp.Sensor (°C): 20.81
  OWBus: Bee.Temp.Sensor (°C): 19.56
  OWBus: Ext.Temp.Sensor (°C): 20.50
  Loop: ADSPort(0-3): 
  ADS: Single-ended read from AIN0: 3.28V - 
  ADS: Single-ended read from AIN1: 4.67V - 
  ADS: Single-ended read from AIN2: 4.06V (91%) - 
  ADS: Single-ended read from AIN3: 2.54V
  Loop[14]: 2020-03-29 14:09:33,-6.82,20.50,20.81,19.56,23.50,3.28,5.08,4.67,4.06,91#14 o.k.
  Log: No SDCard, no local Logfile...
  LoRaLog: BeeIoTStatus = JOIN
  BeeIoTJoin: Start searching for a GW
  BIoT_getmic: Add MIC[4] = 11 22 33 44 for Msg[255]
  LoRaCfg: Set Modem/Channel-Cfg[0]: 868100000Mhz, SF=7, TXPwr:14, BW:125000, CR:5, LPreamble:12     
    SW:0x12, CRC, noInvIQ  LoraCfg: StdBy Mode
  LoRaSend: TXData &lt;PkgLen= 29By&gt;
  sendMessage: Start TX
  LoRaSend(0x80&gt;0x99)[255](cmd=0) &lt;FrmLen: 20By&gt;
MSGfield at 0x3FFC03F0:
Address:  0 1  2 3  4 5  6 7   8 9  A B  C D  E F  length= 29 Byte
  +   0: 9980 FF00 14DC 8AD5  FFFE 286F 24BB EEEE  &lt;..........(o$...&gt;
  +  10: BBEE EECC EE00 0B01  0011 2233 44         &lt;.........."3D&gt;
  BeeIoTJoin: waiting for RX-CONFIG Pkg. in RXCont mode:oo
onReceive: got Pkg: len 0x19
MSGfield at 0x3FFC0470:
Address:  0 1  2 3  4 5  6 7   8 9  A B  C D  E F  length= 5 Byte
  +   0: 8099 FF06 10                              &lt;.....&gt;
onReceive: RX(0x99&gt;0x80)[255]:(cmd=6: CONFIG) DataLen=16 Bytes
  BeeIotJoin: RX pkg received: CONFIG
  BeeIotJoin: RX Queue Status: SrvIdx:0, IsrIdx:1, new PkgID:255, RXFlag:1
  BeeIoTParse[255]: cmd= CONFIG -&gt; switch to new channel cfg.
  BeeIoTParseCfg: New Configuration: BIoT-Interval: 600sec., Verbose:513, ChIndex:0, NDID:0x81, GwID:0x98, MsgCnt:0
  Lora: Joined! New: GWID:0x98, NodeID:0x81, msgcount:0
    DEVEUI: 0x-DC-8A-D5-FF-FE-28-6F-24
   JOINEUI: 0x-BB-EE-EE-BB-EE-EE-CC-EE
  LoRaLog: wait for incoming ACK in RXCont mode (Retry: #0)..
onReceive: RX(0x98&gt;0x81)[1]:(cmd=5: ACK) DataLen=0 Bytes

  LoRaLog: wait for add. RX1 Pkg. (RXCont):oooooo None.

  Main: Going to Deep Sleep - Trigger: Timer only(600 sec.)
</code></pre><h2 id="beeiot-todo-liste"><a name="beeiot-todo-liste" href="#beeiot-todo-liste"></a>BeeIoT ToDo Liste</h2><p>Was im aktuellen BIoT Design noch fehlt:</p><ul>
<li>Collison detection (ist aber ggfs. durch die CRC Prüfung und Resend(RETRY)-Anforderung abgedeckt)</li><li>Payload Encryption auf AES128 Basis (ist bereits in Arbeit)</li><li>Gateway Multi Band management (heute wird nur 1 band gewählt, das aber nur alle 10-15 Minuten benutzt)</li><li>Duty Time recognition</li></ul><p>Viel Spass damit und einen Imkerlichen Gruss<br>wünscht Euch </p><p>Randolph Esser<br>(mail(a)RandolphEsser.de)</p><p><a href="http://www.RandolphEsser.de/Imkerei"><strong>www.RandolphEsser.de</strong></a><br>==&gt; Imkerei</p>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
